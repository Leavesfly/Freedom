# 性能优化

<cite>
**本文档中引用的文件**
- [Optimizer.java](file://src/main/java/alchemystar/freedom/optimizer/Optimizer.java)
- [BPTree.java](file://src/main/java/alchemystar/freedom/index/bp/BPTree.java)
- [PagePool.java](file://src/main/java/alchemystar/freedom/store/page/PagePool.java)
- [Table.java](file://src/main/java/alchemystar/freedom/meta/Table.java)
- [TableFilter.java](file://src/main/java/alchemystar/freedom/sql/select/TableFilter.java)
- [SelectVisitor.java](file://src/main/java/alchemystar/freedom/sql/parser/SelectVisitor.java)
</cite>

## 目录
1. [引言](#引言)
2. [查询优化策略](#查询优化策略)
3. [B+树索引优化](#b+树索引优化)
4. [内存与I/O优化](#内存与i/o优化)
5. [未来优化方向](#未来优化方向)
6. [结论](#结论)

## 引言
本指南旨在深入分析Freedom数据库系统的性能优化机制，重点探讨查询优化、索引结构、内存管理和I/O操作等方面的优化策略。通过分析核心组件的实现逻辑，为开发者提供性能调优的最佳实践和未来改进方向。

## 查询优化策略

### 查询优化器实现
系统通过`Optimizer.java`实现基本的索引选择逻辑。优化器根据查询条件中的键值是否包含主键来决定使用聚簇索引还是二级索引。

```mermaid
flowchart TD
Start([开始查询]) --> CheckPrimaryKey["检查查询条件是否包含主键"]
CheckPrimaryKey --> |包含主键| UseClusterIndex["使用聚簇索引"]
CheckPrimaryKey --> |不包含主键| UseSecondIndex["使用第一个二级索引"]
UseClusterIndex --> End([完成查询])
UseSecondIndex --> End
```

**图示来源**
- [Optimizer.java](file://src/main/java/alchemystar/freedom/optimizer/Optimizer.java#L15-L34)

**本节来源**
- [Optimizer.java](file://src/main/java/alchemystar/freedom/optimizer/Optimizer.java#L15-L34)
- [Table.java](file://src/main/java/alchemystar/freedom/meta/Table.java#L40-L47)

### 执行计划生成
查询执行计划的生成主要在`TableFilter.java`中完成。系统通过解析WHERE条件来确定查询的上下界，从而优化B+树的扫描范围。

```mermaid
sequenceDiagram
participant Parser as SQL解析器
participant Filter as TableFilter
participant Index as B+树索引
Parser->>Filter : 提交WHERE条件
Filter->>Filter : 解析条件并构建上下界
Filter->>Index : 发起范围查询
Index-->>Filter : 返回结果集
Filter-->>Parser : 返回最终结果
```

**图示来源**
- [TableFilter.java](file://src/main/java/alchemystar/freedom/sql/select/TableFilter.java#L100-L180)
- [SelectVisitor.java](file://src/main/java/alchemystar/freedom/sql/parser/SelectVisitor.java#L30-L50)

**本节来源**
- [TableFilter.java](file://src/main/java/alchemystar/freedom/sql/select/TableFilter.java#L100-L180)
- [SelectVisitor.java](file://src/main/java/alchemystar/freedom/sql/parser/SelectVisitor.java#L30-L50)

## B+树索引优化

### B+树结构与访问
系统采用B+树作为主要的索引结构，通过`BPTree.java`实现。B+树的叶子节点通过链表连接，支持高效的范围查询。

```mermaid
classDiagram
class BPTree {
+BPNode root
+BPNode head
+Map<Integer, BPNode> nodeMap
+searchEqual(IndexEntry)
+searchRange(IndexEntry, IndexEntry)
+insert(IndexEntry, boolean)
+delete(IndexEntry)
}
class BPNode {
+List<IndexEntry> entries
+BPNode previous
+BPNode next
+boolean isLeaf
+boolean isRoot
}
class IndexEntry {
+Value[] values
+IndexDesc indexDesc
}
BPTree --> BPNode : "包含"
BPNode --> IndexEntry : "包含"
```

**图示来源**
- [BPTree.java](file://src/main/java/alchemystar/freedom/index/bp/BPTree.java#L30-L50)
- [BPNode.java](file://src/main/java/alchemystar/freedom/index/bp/BPNode.java)

**本节来源**
- [BPTree.java](file://src/main/java/alchemystar/freedom/index/bp/BPTree.java#L30-L50)
- [BPNode.java](file://src/main/java/alchemystar/freedom/index/bp/BPNode.java)

### 索引创建最佳实践
1. **主键索引**：系统自动为表创建聚簇索引，基于主键属性
2. **二级索引**：通过`CreateVisitor.java`中的`buildOneSecondIndex`方法创建
3. **复合索引**：支持多列组合的索引创建

```mermaid
flowchart TD
Start([创建索引]) --> DefineColumns["定义索引列"]
DefineColumns --> AddRowId["添加主键ID作为最后一列"]
AddRowId --> CreateBPTree["创建BPTree实例"]
CreateBPTree --> RegisterIndex["注册到表的二级索引列表"]
RegisterIndex --> End([索引创建完成])
```

**图示来源**
- [CreateVisitor.java](file://src/main/java/alchemystar/freedom/sql/parser/CreateVisitor.java#L58-L73)
- [Table.java](file://src/main/java/alchemystar/freedom/meta/Table.java#L85-L95)

**本节来源**
- [CreateVisitor.java](file://src/main/java/alchemystar/freedom/sql/parser/CreateVisitor.java#L58-L73)
- [Table.java](file://src/main/java/alchemystar/freedom/meta/Table.java#L85-L95)

## 内存与I/O优化

### 页池管理
`PagePool.java`实现了内存页的池化管理，通过对象复用减少GC压力。

```mermaid
classDiagram
class PagePool {
-static PagePool pagePool
-int defaultPageNum = 8
-AbstractQueue<Page> frees
-PageFactory factory
+getFreePage()
+recycle(Page)
+init()
}
class PageFactory {
+newPage()
+newBpPage(BPNode)
}
class Page {
+boolean dirty
+int length
+BufferWrapper bufferWrapper
}
PagePool --> Page : "管理"
PageFactory --> Page : "创建"
PagePool --> PageFactory : "使用"
```

**图示来源**
- [PagePool.java](file://src/main/java/alchemystar/freedom/store/page/PagePool.java#L15-L51)
- [PageFactory.java](file://src/main/java/alchemystar/freedom/store/page/PageFactory.java)
- [Page.java](file://src/main/java/alchemystar/freedom/store/page/Page.java)

**本节来源**
- [PagePool.java](file://src/main/java/alchemystar/freedom/store/page/PagePool.java#L15-L51)
- [PageFactory.java](file://src/main/java/alchemystar/freedom/store/page/PageFactory.java)
- [Page.java](file://src/main/java/alchemystar/freedom/store/page/Page.java)

### I/O优化策略
1. **延迟写入**：仅当页被标记为脏页时才进行写入操作
2. **批量刷新**：通过`flushToDisk`方法批量将索引数据写入磁盘
3. **元数据页**：使用固定的页号0存储B+树根节点信息

```mermaid
sequenceDiagram
participant Memory as 内存
participant Disk as 磁盘
participant PagePool as 页池
PagePool->>Memory : 分配新页
Memory->>PagePool : 使用后回收
PagePool->>Disk : 批量写入脏页
Disk-->>PagePool : 确认写入完成
PagePool->>Memory : 标记页为干净
```

**图示来源**
- [BPTree.java](file://src/main/java/alchemystar/freedom/index/bp/BPTree.java#L250-L270)
- [PagePool.java](file://src/main/java/alchemystar/freedom/store/page/PagePool.java#L45-L51)

**本节来源**
- [BPTree.java](file://src/main/java/alchemystar/freedom/index/bp/BPTree.java#L250-L270)
- [PagePool.java](file://src/main/java/alchemystar/freedom/store/page/PagePool.java#L45-L51)

## 未来优化方向

### 索引选择优化
当前优化器仅支持简单的索引选择策略，未来可改进的方向包括：
- 基于统计信息的成本估算
- 多索引的组合使用
- 索引选择的动态调整

```mermaid
flowchart TD
Current([当前策略]) --> SimpleRule["基于规则的简单选择"]
Future([未来方向]) --> CostBased["基于成本的优化"]
Future --> Statistics["利用统计信息"]
Future --> Dynamic["动态索引选择"]
Future --> MultiIndex["多索引组合"]
```

**本节来源**
- [Optimizer.java](file://src/main/java/alchemystar/freedom/optimizer/Optimizer.java#L25-L30)

### 执行计划缓存
建议实现执行计划缓存机制，避免重复解析相同查询。

```mermaid
classDiagram
class PlanCache {
-Map<String, ExecutionPlan> cache
+getPlan(String sql)
+putPlan(String sql, ExecutionPlan plan)
+invalidate(String table)
}
class ExecutionPlan {
+TableFilter tableFilter
+Index chosenIndex
+Cursor cursor
}
PlanCache --> ExecutionPlan : "存储"
```

**本节来源**
- [Table.java](file://src/main/java/alchemystar/freedom/meta/Table.java#L40-L47)
- [TableFilter.java](file://src/main/java/alchemystar/freedom/sql/select/TableFilter.java)

## 结论
Freedom数据库系统已经实现了基本的性能优化机制，包括B+树索引、页池管理和简单的查询优化。通过合理使用现有优化策略，可以显著提升系统性能。未来可通过引入更智能的优化器、执行计划缓存等高级特性进一步提升系统性能。